" vim: fdm=marker foldlevel=0
scriptencoding utf-8

" {{{ Plugins

let g:plugins_file_path = '~/.vim/plugins.vim'

if filereadable(expand(g:plugins_file_path))
  exe ':source ' . g:plugins_file_path
endif

filetype plugin indent on

" }}}
" {{{ Basics

set nobackup
set noswapfile
set directory=~/.vim-tmp,~/.tmp,/var/tmp,/tmp
if exists('+undofile')
  set undofile
  set undodir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
endif

set history=10000
set undolevels=1000
set foldlevel=999

set shell=zsh
set mouse=nvi " enable mouse
set cursorline " highlight current line
set hidden " allow buffers in background
set number " line numbers
set listchars=tab:»·,trail:· " invisible chars
set list " show tabs and trailing whitespace

set wildmode=longest:list,full " tab completion
set laststatus=2 " always show status bar
set wildignorecase " ignore case when completing filenames in command mode
set ignorecase smartcase " search is case insensitive unless when upper case
set gdefault " global search by default; /g for first-per-row only.

set autoindent " indent to current depth on new lines
set expandtab " spaces for tabs
set tabstop=2
set shiftwidth=2
set softtabstop=2

set autoread " update files when coming back

set exrc " auto load local .vimrc files
set secure " … but lets keep it secure

set spelllang=da

" ag for ack
" brew install the_silver_searcher
if executable('rg')
  set grepprg=rg\ --vimgrep
endif

if has('nvim')
  set termguicolors " Use millions of colors
endif

" }}}
" {{{ Mappings

let g:mapleader="\<Space>"

" jumping
nnoremap <leader><leader> <c-^>
" so fast save save save
nmap <leader>j :w<cr>
" / to search, <c-/> to clear search
" term:
noremap <c-_> :set hlsearch!<cr>
" gui:
noremap <c-/> :set hlsearch!<cr>
" old leader is the new project wide search
nnoremap \ :Ack<SPACE>

" qq to record, Q to replay
nmap Q @q
vmap Q :normal Q<cr>

" %% expands to dir of current file in cmd mode
cmap %% <C-R>=expand('%:h').'/'<cr>
" edit file in the same directory as the current file
nmap <leader>e :edit %%

" visual moving
noremap k gk
noremap j gj
noremap gk k
noremap gj j

" Easy split navigation
nnoremap <C-h>  <C-w>h
nnoremap <C-j>  <C-w>j
nnoremap <C-k>  <C-w>k
nnoremap <C-l>  <C-w>l

" tabs
nnoremap ]w :tabn<cr>
nnoremap [w :tabp<cr>

" Y behaves like other capital letters
nnoremap Y y$

" always jump to mark column (and not just line)
noremap ' `

" Indenting visual selection keeps selection
vnoremap < <gv
vnoremap > >gv

" Open pwd in Finder.app
nnoremap <leader>O :call system('open .')<cr>

" Just, you know, close the bottom window
nnoremap <silent> <c-w>z :wincmd z<bar>cclose<bar>lclose<cr>

" c-c doesn't trigger InsertLeave by default so we map it to regular esc
xnoremap <c-c> <esc>
inoremap <c-c> <esc>

" Shortcuts to configs
nmap <leader>vv :e ~/.vimrc<cr>
nmap <leader>vp :e <c-r>=g:plugins_file_path<cr><cr>

" set <cr> to reload browsers
" for the scripts, see https://github.com/mikker/dotfiles/tree/master/bin
noremap <leader>mc :Rerun call system('reload-chrome')<cr>
noremap <leader>ms :Rerun call system('reload-safari')<cr>
noremap <leader>mr :Rerun call system('reload-firefox')<cr>

" wait what time is it?
iab <expr> ddate strftime("%Y-%m-%d")
iab <expr> ttime strftime("%H:%M")

" stupid hands
cnoreabbrev E e
cnoreabbrev G Git
cnoreabbrev Qa qa

" }}}
" {{{ Functions and commands

" Open current file in Marked.app
command! Marked call system('open -a Marked\ 2 "'.expand('%').'"')

" Quicker filetype setting:
"   :F html
command! -nargs=1 F set filetype=<args>

" find and delete all trailing whitespace
fun! <SID>StripTrailingWhitespaces()
  let l:l = line('.')
  let l:c = col('.')
  %s/\s\+$//e
  call cursor(l:l, l:c)
endfun
noremap <leader>S :call <SID>StripTrailingWhitespaces()<cr>

" TT runs a terminal command in a new tab before the current one
"   :TT [terminal command]
fun! s:runTermInTab(args)
  execute '-tabnew|term ' . expand(a:args)
  normal i
endfun
command! -nargs=* -complete=file TT call s:runTermInTab(<q-args>)

" }}}
" {{{ Autocommands
augroup vimrcEx
  autocmd!

  " Auto-open quickfix window after grep cmds
  autocmd QuickFixCmdPost *grep* cwindow

  " magic markers: enable using `H/S/J/C to jump back to
  " last HTML, stylesheet, JS or app code buffer
  au BufLeave *.{erb,html,haml,slim,eex} exe "normal! mH"
  au BufLeave *.{css,scss}               exe "normal! mS"
  au BufLeave *.{js,jsx,ts,tsx}          exe "normal! mJ"
  au BufLeave *.{rb,ex,exs}              exe "normal! mC"
  au BufLeave *.yml                      exe "normal! mY"

  " au BufRead *.mkd,*.md set ai formatoptions=tcroqn2 comments=n:>
augroup END

if has('nvim')
  " <esc> goes to normal mode in term buffers
  tnoremap <esc> <c-\><c-n>

  " Close finished term buffers with <cr> in nvim
  augroup nvimrcEx
    autocmd!
    au TermOpen * nmap <buffer> <cr> :bd!<cr>
  augroup END

  " :s command real-time preview
  set inccommand=nosplit
end

" }}}
" Plugin config and maps {{{

" FZF
noremap <leader>f :FZF<cr>
nnoremap <silent> <Leader>b :Buffers<cr>

xmap <cr> :EasyAlign<cr>

let g:lightline = {
      \  'colorscheme': 'pencil',
      \  'separator': { 'left': '', 'right': '' },
      \  'subseparator': { 'left': '', 'right': '' },
      \  'active': {
      \    'left': [
      \       ['mode', 'paste'],
      \       ['readonly', 'filename', 'fugitive', 'cocstatus']
      \    ],
      \    'right': [['filetype'], ['gutentags']]
      \  },
      \  'component_function': {
      \    'filename': 'LightLineFilename',
      \    'fugitive': 'fugitive#head',
      \    'gutentags': 'gutentags#statusline',
      \    'cocstatus': 'coc#status'
      \  }
      \}

function! LightLineModified()
  if &filetype ==# 'help'
    return ''
  elseif &modified
    return '[+]'
  else
    return ''
  endif
endfunction

function! LightLineFilename()
  return ('' !=# expand('%f') ? expand('%f') : '[No Name]') .
       \ ('' !=# LightLineModified() ? LightLineModified() : '')
endfunction

com! Wiki FZF ~/Dropbox/Wiki/
nnoremap <leader>W :Wiki<cr>

" Use :TT for vim-test
fun! TTStrategy(cmd)
  execute 'TT ' . a:cmd
endfun

let g:test#custom_strategies = { "tt": function('TTStrategy') }

if has('nvim')
  let test#strategy = "tt"
else
  let test#strategy = "basic"
endif

nmap <silent> <leader>tt :TestNearest<CR>
nmap <silent> <leader>tT :TestFile<CR>
nmap <silent> <leader>ta :TestSuite<CR>
nmap <silent> <leader>tl :TestLast<CR>
nmap <silent> <leader>tg :TestVisit<CR>

let g:rerunner_focus = 'TestLast'
map <leader>md :Rerun TestLast<cr>

let g:colorizer_nomap = 1

augroup pencil
  autocmd!
  autocmd FileType markdown,mkd,text call pencil#init()
augroup END

let g:pencil#wrapModeDefault = 'soft'
let g:pencil#conceallevel = 0
let g:pencil#concealcursor = 'c'

map <leader>G :Goyo<cr>

call togglebg#map("<f5>")

" }}}

set background=light
colo paramount

" when in VimR.app
if has("gui_vimr")
  " act as in a term
  nmap <c-z> :term<cr>
  " shift-tab sends ctrl+shift+y
  " au! FileType vimwiki map <buffer> <c-s-y> :VimwikiPrevLink<cr>

  set background=light

  cd ~/Dropbox/Wiki

  let g:goyo_height = '100%'

  fun! s:initVimR()
    if eval("@%") == ""
      " execute 'VimwikiIndex'
    end
  endfun

  au! VimEnter * call s:initVimR()
endif

let g:ale_completion_enabled = 1
nnoremap <leader>F :ALEFix<cr>

" COC COC COC

" Smaller updatetime for CursorHold & CursorHoldI
set updatetime=300

" don't give |ins-completion-menu| messages.
set shortmess+=c

" " Use tab for trigger completion with characters ahead and navigate.
" " Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
" inoremap <silent><expr> <TAB>
"       \ pumvisible() ? "\<C-n>" :
"       \ <SID>check_back_space() ? "\<TAB>" :
"       \ coc#refresh()
" inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

" function! s:check_back_space() abort
"   let col = col('.') - 1
"   return !col || getline('.')[col - 1]  =~# '\s'
" endfunction

" " Use <c-space> for trigger completion.
" " inoremap <silent><expr> <c-space> coc#refresh()

" " Use <cr> for confirm completion, `<C-g>u` means break undo chain at current position.
" " Coc only does snippet and additional edit on confirm.
" " inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" Use `[c` and `]c` for navigate diagnostics
nmap <silent> [c <Plug>(coc-diagnostic-prev)
nmap <silent> ]c <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Use K for show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if &filetype == 'vim'
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Highlight symbol under cursor on CursorHold
autocmd CursorHold * silent call CocActionAsync('highlight')

" " Remap for rename current word
" nmap <leader>rn <Plug>(coc-rename)

" " Remap for format selected region
" vmap <leader>F  <Plug>(coc-format-selected)
" nmap <leader>F  <Plug>(coc-format-selected)

" augroup mygroup
"   autocmd!
"   " Setup formatexpr specified filetype(s).
"   autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
"   " Update signature help on jump placeholder
"   autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
" augroup end

" " Remap for do codeAction of selected region, ex: `<leader>aap` for current paragraph
" vmap <leader>a  <Plug>(coc-codeaction-selected)
" nmap <leader>a  <Plug>(coc-codeaction-selected)

" " Remap for do codeAction of current line
" nmap <leader>ac  <Plug>(coc-codeaction)
" " Fix autofix problem of current line
" nmap <leader>qf  <Plug>(coc-fix-current)

" " Use `:Format` for format current buffer
" command! -nargs=0 Format :call CocAction('format')

" " Use `:Fold` for fold current buffer
" command! -nargs=? Fold :call     CocAction('fold', <f-args>)

" " Using CocList
" " Show all diagnostics
" nnoremap <silent> <space>a  :<C-u>CocList diagnostics<cr>
" " Manage extensions
" " nnoremap <silent> <space>e  :<C-u>CocList extensions<cr>
" " Show commands
" nnoremap <silent> <space>c  :<C-u>CocList commands<cr>
" " Find symbol of current document
" nnoremap <silent> <space>o  :<C-u>CocList outline<cr>
" " Search workspace symbols
" nnoremap <silent> <space>s  :<C-u>CocList -I symbols<cr>
" " Do default action for next item.
" nnoremap <silent> <space>]  :<C-u>CocNext<CR>
" " Do default action for previous item.
" nnoremap <silent> <space>[  :<C-u>CocPrev<CR>
" " Resume latest coc list
" nnoremap <silent> <space>p  :<C-u>CocListResume<CR>

